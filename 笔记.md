重见项目六 : 

# 电脑装配

笔记使用教程地址-------------

https://www.bilibili.com/video/BV14f4y1Q7eu/?spm_id_from=333.337.search-card.all.click&vd_source=67649634b24452a5170dd26024c27a9b

当前电脑版本 : 

```
maven(查看方法 :mvn -version) :  3.8.X
mysql(查看方法 :mysql -u root -p) :  5.5.25
redis(查看方法 :启动redis就能看到 )  : 5.0.9
node.js(查看方法 :node -v )  : 10.16.0
npm(查看方法 : npm -v)  : 6.9.0
```

## maven相关安装 : 

### 查看maven版本 ; 

```
cmd--->mvn -version-->Apache Maven 3.8.6 (84538c9988a25aec085021c365c560670ad80f63)
```

### 之前的maven 地址 ; 

```
Maven home directory:   
E:/bianchengruanjian/idea/IntelliJ IDEA 2020.2.1/plugins/maven/lib/maven3

User settings file: 
C:\Users\Administrator\.m2\settings.xml

Local repository: 
E:\bianchengruanjian\maven\apache-maven-3.3.9\repository
```



### 下载地址 ;

https://maven.apache.org/download.cgi

### 参考地址 ; 

https://blog.csdn.net/weixin_46565024/article/details/122758111

### idea更换maven配置 :

https://blog.csdn.net/qq_38190185/article/details/115943152?spm=1001.2014.3001.5501 

## node相关 : 

node安装及配置方法

https://blog.csdn.net/qq_43557395/article/details/124325563

查看node.js版本

```
查看本地计算机的Node.js版本
cmd---->node -v---->v10.16.0

查看node.js的npm版本
npm -v-->6.9.0
```

## mysql相关 ; 

```
查看本地计算机的mysql版本
cmd-->mysql -u root -p--->Server version: 5.5.25 MySQL Community Server (GPL)


```




## redis相关 :

安装 ; 解压即安装 ; Redis-x64-5.0.9(学习的版本)

下载地址 :  https://github.com/MicrosoftArchive/redis/releases 

参考网站 :https://blog.csdn.net/weixin_44096133/article/details/114938881?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167038334416782388022088%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167038334416782388022088&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-114938881-null-null.142^v67^control,201^v4^add_ask,213^v2^t3_esquery_v2&utm_term=redis%E4%B8%8B%E8%BD%BD%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187

### 配置

请搜索--[ 修改配置文件 Redis.Windows.conf 增加密码 ]

## node.js相关 :

安装教程 ; https://blog.csdn.net/wuliyouMaozhi/article/details/126071233?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167038534416800182742929%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167038534416800182742929&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-126071233-null-null.article_score_rank_blog&utm_term=node.js%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A&spm=1018.2226.3001.4450

相关命令 : 

```
查看node版本             node -v
```

mac系统

| 清除npm缓存，执行命令                      | npm cache clean -f                                           |
| ------------------------------------------ | ------------------------------------------------------------ |
| n模块是专门用来管理nodejs的版本，安装n模块 | npm install -g n                                             |
| 更新升级node版本                           | n stable // 把当前系统的 Node 更新成最新的 “稳定版本” <br />n lts // 长期支持版<br/>n latest // 最新版<br/>n 10.14.2 // 指定安装版本 |
| 删除指定node版本                           | n rm 12.22.0                                                 |
| 查看升级后的node版本                       | node -v                                                      |

 注意：在终端中可能会遇到权限问题，在开始位置输入 sudo  即可 

window系统

```
cmd查看当前node版本和node安装位置
node -v
where node
```



## npm相关 :

# 错误集: 

```
报错信息 :
    No qualifying bean of type 'cn.itsource.ymcc.mapper.AccountFlowMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
--原因 : 是因为项目未扫描到 mapper 包。
--解决方法 :
    在启动类上加 ;
     @MapperScan(value = "cn.itsource.ymcc.mapper")//--加这个注解的理由如下--本来每必要加的---把mapper注入容器
     //因为报错    ---No qualifying bean of type 'cn.itsource.ymcc.mapper.MessageEmailMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}

报错信息 :
    Ambiguous mapping. Cannot map 'userController' method
--原因 : 在指定方法所对应的url地址的时候重复了, 也就是@RequestMapping("url")中, 两个方法使用了同一个url路径
    查找controller层是否有相同路径的方法
--解决方法 : 

报错信息 : 找不到或无法加载主类com.xxx.xxx.Application(完美解决)(找不到或无法加载主类 com.ruoyi.monitor.admin.MonitorAdminApplication)
--原因 :  查看网页 : https://blog.csdn.net/qq_53314126/article/details/118939259
--解决方法  :

报错信息 : 
--原因 :
--解决方法  :

报错信息 : 
--原因 :
--解决方法  :

报错信息 : 
--原因 :
--解决方法  :

报错信息 : 
--原因 :
--解决方法  :

报错信息 : 
--原因 :
--解决方法  :

报错信息 : 
--原因 :
--解决方法  :





```



# idea常用快捷键

```
大小写格式转换 : Ctrl+ shift + U
变量名中文转英文 :  Ctrl + Shift + X
在某个方法中，会展示出这个方法的调用参数列表信息 : Ctrl + P
展示某个类或者方法的 API 说明文档 : Ctrl + Q
展开或收缩代码段。 (常用)  : Ctrl + NumPad(+/-)
展开所有代码段。 : Ctrl + Shift + NumPad(+)
收缩所有代码段。 : Ctrl + Shift + NumPad(-)
该类中所有覆盖或者实现的方法列表 :  Ctrl + O 
生成具有环绕性质的代码 :  Ctrl + Alt + T  (比如if.try)
```



# 常用流程 : 

## 	登录流程

```
一  : 校验
1.校验 (空校验,格式校验)
2.格式校验
二 : 验证码
1.校验手机号师父发送过验证码
2.从redis拿到了验证码
	2.1 没有过重发时间 , 使劲骂
	2.2 过了重发时间 , 使用还没有过期的码儿
3.拿不到
	3.1 生成验证码
	3.2 存储验证码到redis中
	3.3 发送验证码短信
	3.4 存发送短信的信息到数据库
```

注册流程: 

```
1.前段发送参数传递到后端进行注册
2.使用JSR303校验
3.获取到redis中的验证码 , 判断是否存在
	3.1 不存在 . 抛异常
	3.2 存在 比较是否一致
		如果不一致抛异常
4. 根据手机号查询user表 , 判断是否存在,
	如果存在就跑异常
5. 保存login表 (在api-uaa中编写feign接口 ,  让user服务依赖此服务,可以使用feign接口)	
6.保存user表
7.保存user相关表
```

# 中间件安装

## nacos安装 和使用;   

下载地址：[https://github.com/alibaba/nacos/releases](https://github.com/alibaba/nacos/releases)

解压即安装 

Windows执行bin目录下的startup命令 ; startup.cmd-m standdalone

linux 执行 ：sh startup.sh -m standalone

```
将nacos版本换成1.4.1，点击启动，第一行显示"nacos is starting with cluster"，然后启动失败。
失败原因：
“nacos is starting with cluster”，意为nacos以群集模式启动。于是，查了一下1.1.3到1.1.4的相关差异，得知1.4.1的默认启动模式是集群模式。而集群模式在没有进行集群配置的情况下，就会启动失败。
解决办法：将startup.cmd中的set MODE="cluster"修改为set MODE=“standalone”。

```

启动完成 ; 访问  ;;  http://127.0.0.1:8848/nacos/index.html

原始配置文件里面的34-64行   防止以后改错 , 备份一份

```properties
### Count of DB:
# db.num=1

### Connect URL of DB:
# db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
# db.user.0=nacos
# db.password.0=nacos

### Connection pool configuration: hikariCP
db.pool.config.connectionTimeout=30000
db.pool.config.validationTimeout=10000
db.pool.config.maximumPoolSize=20
db.pool.config.minimumIdle=2

#*************** Naming Module Related Configurations ***************#
### Data dispatch task execution period in milliseconds: Will removed on v2.1.X, replace with nacos.core.protocol.distro.data.sync.delayMs
# nacos.naming.distro.taskDispatchPeriod=200

### Data count of batch sync task: Will removed on v2.1.X. Deprecated
# nacos.naming.distro.batchSyncKeyCount=1000

### Retry delay in milliseconds if sync task failed: Will removed on v2.1.X, replace with nacos.core.protocol.distro.data.sync.retryDelayMs
# nacos.naming.distro.syncRetryDelay=5000

### If enable data warmup. If set to false, the server would accept request without local data preparation:
# nacos.naming.data.warmup=true

### If enable the instance auto expiration, kind like of health check of instance:
# nacos.naming.expireInstance=true

```

### 使用

相当于一个 注册中心 和一个配置中心

引入依赖 : 

```xml
 <!--        引入nacos配置中心-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
        
        <!-- 服务注册与发现-->
        <dependency>
            <groupId>com.alibaba.cloud </groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>

```

刷新配置

下面的Controller用来做配置刷新测试，`temp.notify`对应了配置文件中的配置项目。`@RefreshScope`注解是用来做配置自动刷新。那么当我们修改了Nacos中的配置文件，Controller中读取到的配置`temp.notify`将会自动变化。

```java
@RefreshScope  //刷新配置
@RestController
public class UserController {

    @Value("${name}")
    private String name;

    @GetMapping("/user/{id}")
    public User getById(@PathVariable Long id){
        System.out.println("测试配置notify="name);
        return new User(id,"zs:"+id, "我是zs");
    }
}

```

```
1.创建gateway
	集成nacos discovery（服务注册与发现）
		导入nacos discovery依赖
		启动类注解 (@enablediscoveryclient)
		yml配置（端口号，nacos discovery的地址，服务名）
集成nacos config（配置中心）
	导入nacos config
	yml : 
		bootstrap.yml
			nacos config 地址 
			指定哪个配置文件
			环境
			前缀
			后缀
			组名
			命名空间
集成gateway
	导入gateway的依赖
	启动类添加注解 
	配置文件
		路由信息
```

## Redis安装使用:

### 安装

解压即安装 ;

Redis-x64-5.0.9

### 设置密码 : 

​	修改配置文件 Redis.Windows.conf 增加密码

```
原来的443行
# requirepass foobared
修改之后的443行
requirepass 123456    这行必须顶格写

```

### 设置持久化方式

持久化文件在Redis文件夹里面 :  

​		dump.rdb   直接删掉Redis中的内存的数据就没有了    默认打开    记录的是快照

```
有一个触发时间阶梯在Redis.Windows.conf 里面194-196行

```

​		appendonly.aof 需要手动打开 .记录的是命令 , 需要在Redis.Windows.conf里面手动打开

```
在Redis.Windows.conf 里面581行
581 appendonly yes   这个记录的是命令  
备份的文件也在Redis文件中 . 文件名是 appendonly.aof
```

### 序列化			

Redis 里面存放对象需要这个对象去实现序列化接口

​	序列化,把内存中的存放在磁盘中去

```
public class User implements Serializable{}     对象实现序列化接口
```

### 设置淘汰策略

在Redis.Windows.conf里面设置   -   

```
# maxmemory-policy noeviction      需要用哪个就把哪个去替换noeviction , 然后放开这行顶格
```

常用的：

~~~
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
allkeys-lru：从所有数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
~~~

不常用：

~~~
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据
~~~

```
noeviction：不驱逐任何key
allkeys-ttl：删除马上过期的key
allkeys-lru：对所有key使用LRU算法进行删除（生产推荐）
volatile-lru：对所有设置了过期时间的key使用LRU算法进行删除
allkeys-random：对所有key随机删除
volatile-random：对所有设置了过期时间的key随机删除
allkeys-lfu：对所有key使用LFU算法进行删除
volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除
配置内存淘汰策略：
————————————————
版权声明：本文为CSDN博主「晴日朗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42947952/article/details/127245470
```

### 设置内存大小--在Redis.conf里面 

```
maxmemory 500mb
```

先启动服务端-在启动客服端

### 1.导入依赖

登录是公共的service.把依赖放到公共的接口里面

```xml
<!--整合Redis , 底层可以用jedis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <!--排除redis默认的java开发客户端依赖，因为高并发情况下会有内存溢出问题，我们使用jedis来操作Java-->
    <exclusions>
        <exclusion>
            <groupId>io.lettuce</groupId>
            <artifactId>lettuce-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!--引入redis的java客户端包，jedis依赖-->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
```

### 第二步yml文件

### 第三步 : 序列化文件

```Java
//缓存的配置
@Configuration
public class RedisConfig {

    @Resource
    private RedisConnectionFactory factory;


    //使用JSON进行序列化
    @Bean
    public RedisTemplate<Object, Object> redisTemplate() {
        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();

        redisTemplate.setConnectionFactory(factory);
        //JSON格式序列化
        GenericFastJsonRedisSerializer serializer = new GenericFastJsonRedisSerializer();
         //key的序列化
        redisTemplate.setKeySerializer(serializer);
        //value的序列化
        redisTemplate.setValueSerializer(serializer);
        //hash结构key的序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //hash结构value的序列化
        redisTemplate.setHashValueSerializer(serializer);
        return redisTemplate;
    }

} 
```

### 注入使用

## MQ安装和使用

消息队列:提供消息队列的中间件  FIFO

优点 : 消峰.异步,解耦.

MQ的使用场景

- 限流削峰		

  ```
  MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统 被压垮。
  ```

  异步&解耦		

  ```
  上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。 而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。 即使消费者挂掉也不影响生产者工作，只要把消息放入队列即可，消费者重启后自己消费即可。
  ```

  数据收集		

  ```
  分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或 批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此 类数据收集是最好的选择。
  ```

  大数据处理		

  ```
  比如我们的平台向“三方平台”获取数据，一次请求了大量数据回来要进行处理，由于数据较多处理不过来，那么就可以放入MQ，再创建一些消费者进行数据处理即可。
  ```

  【`注意`】如下情况不太适合MQ

​			小项目，体量不大，并发量低的使用MQ会太过笨重 - 你可以考虑使用Redis做一个消息队列。

​			对数据的一致性有要求(强一致性)的的场景不适合使用MQ，因为MQ是异步的。

### 使用MQ的好处(了解)

- 提高系统响应速度

  ​		任务异步处理。 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处		理。提高了应用程序的响应时间。

- 提高系统稳定性

  ​		一是并发被消峰后，系统不容易被高并发打垮，二是系统挂了也没关系,操作内容放到消息队列		不丢失，后续重新消费者一样能消费做业务处理。 

- 排序保证 FIFO

  ​		遵循队列先进先出的特点，能够保证消息按照添加的数据被消费。

mq {rabbitMq . rocketMq . kafka}

技术选型建议：

- 业务场景简单，允许数据丢失，想要快速上线，推荐使用Redis
- 大数据场景，日志收集，实时性要求高，推荐Kafka
- 金融领域，不能接受消息丢失或重复，推荐使用RabbitMQ或者RocketMQ

特点 :

	分布式的实时文件存储，每个字段都被索引并可被搜索
	支持实时分析搜索
	可以扩展到上百台服务器，处理PB级结构化或非结构化数据
	通过简单的 RESTfu  API、可以跟各种语言的客户端甚至命令行进行交互
	上手非常容易，只需很少的学习就可以在生产环境中使用

### rocketMq 的安装 : 

我们学习的是4.2.0

#### 第一步 : 解压即安装 :  

#### 第二步 : 配置环境变量

​	新建系统变量: ROCKETMQ_HOME    ; 变量值 : 配置到bin的上一层 

```
E:\bianchengruanjian\zhong--jian--jian\rocketmq\rocketmq-all-4.2.0-bin-release
```

#### 第三步: 修改占用内存,默认有点大,

​	位置在: bin下面的runbroker.cmd

```
31行	
set "JAVA OPT=&JAVA OPT -server -Xms2g -Xmx2g -Xmn1g"
改为
set "JAVA OPT=&JAVA OPT -server -Xms1g -Xmx1g -Xmn512m"

```

就装完了

#### 启动三个东西.

1 . bin下 Cmd命令框执行进入至`MQ文件夹\bin`下，然后执行 `start mqnamesrv.cmd`，启动NameServer。===成功后会弹出提示框，此框勿关闭。

2 . bin下 CMD执行`start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true` ，启动Broker。==成功后会弹出提示框，此框勿关闭



#### 还差一个可视化界面 :  

rocketmq-externals-rocketmq-console-1.0.0

可视化软甲安装 ; 解压即安装,把他放在和Mq的bin文件夹同级

修改可视化界面的设置.  可视文件resource下面的application.properties文件

```
第10行 rocketmq.config.namesrvAddr=127.0.0.1:9876
```

使用需要打成jar包

在pom.xml界面 cmd 

```
mvn clean package -Dmaven.test.skip=true
```

打包好的文件在target文件里面 文件名是 : rocketmq-console-ng-1.0.0.jar

把这个文件拷到mq的安装目录下.    和mq的Bin文件同级

启动它的方法是当前目录下-CMD执行 `java -jar rocketmq-console-ng-1.0.0.jar`  ， 访问 <http://localhost:8080>       有可能第一次访问不到,全部重启一次就可以了



#### **设置一键启动:** 

rocketmq-start.bat   放在es的bin同级,发送快捷方式到桌面

```
start bin\mqnamesrv.cmd
start bin\mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true
java -jar rocketmq-console-ng-1.0.0.jar
```



### meavn使用rocketmq : 

官网 : https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md

#### 第一步 : 依赖

```xml
<!--注意和安装的MQ版本一致  rocketmq 依赖-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.8.0</version>
</dependency>
```

#### 第二步 : 具体使用

##### **同步消息**

生产者

```Java
public class Producer {
    public static void main(String[] args) throws Exception {
        // 1.创建生产者对象，并指定生产者组名  要和消费者着组名一致
        DefaultMQProducer producer = new DefaultMQProducer("sync_group_producer");
        // 2.连接nameserver
        producer.setNamesrvAddr("127.0.0.1:9876");
        // 3.启动生产者
        producer.start();
        // 4.创建消息对象
        Message message = new Message("sync", "hello", "我在源码学Java,我爱源码！".getBytes(StandardCharsets.UTF_8));
        // 5.发送消息
        SendResult result = producer.send(message);
        System.out.println(result);
        // 6.关闭生产者
        producer.shutdown();
    }
}
```

消费者

步骤分析

1. 创建producer组
2. 设置NameServer地址 ： 如果实在安装不上，可以使用这个地址：115.159.88.63:9876
3. startr生产者
4. 发送消息获取结果
5. 结束producer

```Java
public class Consumer {
    public static void main(String[] args) throws Exception {
        // 1.创建消费者，并指定组名 要和生产着组名一致
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("sync_group_consumer");
        // 2.连接nameserver的端口
        consumer.setNamesrvAddr("127.0.0.1:9876");
        // 3.订阅主题
        consumer.subscribe("sync", "hello");
        // 4.监听消息
        consumer.registerMessageListener((List<MessageExt> list, ConsumeConcurrentlyContext context) -> {
                    for (MessageExt message : list) {
                        //把消息体转为String
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }
                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                }
        );
        // 5.启动
        consumer.start();
    }
}
```

##### 异步消息

生产者

```Java
public class Producer {
    public static void main(String[] args) throws Exception {
        // 1.创建生产者对象，并指定生产者组名
        DefaultMQProducer producer = new DefaultMQProducer("xhr_group_producer");
        // 2.连接nameserver
        producer.setNamesrvAddr("127.0.0.1:9876");
        // 3.启动生产者
        producer.start();
        // 4.创建消息对象
        Message message = new Message("xhr", "hello", "我在源码学Java,我爱源码！".getBytes(StandardCharsets.UTF_8));
        // 5.发送消息
        producer.send(message, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                System.out.println("发送消息成功！");
            }
            @Override
            public void onException(Throwable throwable) {
                throwable.printStackTrace();
                // 失败我们需要重试!
                System.out.println("发送消息失败");
            }
        });
        // 6.关闭生产者
        // producer.shutdown();
    }
}
```

消费者

```Java
public class Consumer {
    public static void main(String[] args) throws Exception {
        // 1.创建消费者，并指定组名
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("xhr_group_consumer");
        // 2.连接nameserver
        consumer.setNamesrvAddr("127.0.0.1:9876");
        // 3.订阅主题
        consumer.subscribe("xhr", "hello");
        // 4.监听消息
        consumer.registerMessageListener((List<MessageExt> list, ConsumeConcurrentlyContext context) -> {
                    for (MessageExt message : list) {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }
                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                }
        );
        // 5.启动
        consumer.start();
    }
}
```

##### **单向消息**

##### **延迟消息**

生产者

```Java
public class Producer {
    public static void main(String[] args) throws Exception {
        // 1.创建生产者对象，并指定生产者组名
        DefaultMQProducer producer = new DefaultMQProducer("delay_group_producer");
        // 2.连接nameserver
        producer.setNamesrvAddr("127.0.0.1:9876");
        // 3.启动生产者
        producer.start();
        // 4.创建消息对象
        Message message = new Message("delay", "hello", "我在源码学Java,我爱源码！".getBytes(StandardCharsets.UTF_8));

        // 设置消息延迟级别
        message.setDelayTimeLevel(3);

        // 5.发送消息
        producer.send(message, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                System.out.println("发送消息成功！");
            }
            @Override
            public void onException(Throwable throwable) {
                throwable.printStackTrace();
                // 失败我们需要重试!
                System.out.println("发送消息失败");
            }
        });
        // 6.关闭生产者
        // producer.shutdown();
    }
}
```

消费者

```Java
public class Consumer {
    public static void main(String[] args) throws Exception {
        // 1.创建消费者，并指定组名
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("delay_group_consumer");
        // 2.连接nameserver
        consumer.setNamesrvAddr("127.0.0.1:9876");
        // 3.订阅主题
        consumer.subscribe("delay", "hello");
        // 4.监听消息
        consumer.registerMessageListener((List<MessageExt> list, ConsumeConcurrentlyContext context) -> {
                    try {
                        for (MessageExt message : list) {
                            System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                        }
                        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 消息签收
                    } catch (Exception e) {
                        e.printStackTrace();
                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;// 消息需要重发
                    }
                }
        );
        // 5.启动
        consumer.start();
    }
}
```

##### **事务消息**

###### 生产者

```Java
public class Producer {

    public static void main(String[] args) throws Exception {
        // 1.创建事务生产者对象，并指定生产者组名
        TransactionMQProducer producer = new TransactionMQProducer("tran_group_producer");
        // 2.连接nameserver
        producer.setNamesrvAddr("127.0.0.1:9876");
        producer.setTransactionListener(new MyTranListener());   //传入一个事务监听器
        // 3.启动生产者
        producer.start();
        // 4.创建消息对象
        Message message = new Message("tran", "hello", "我在源码学Java,我爱源码！".getBytes(StandardCharsets.UTF_8));
        // 5.发送消息
        SendResult result = producer.sendMessageInTransaction(message, null);
        System.out.println(result);
        // 6.关闭生产者
        producer.shutdown();
    }
}
```

###### 消费者

```Java
public class Consumer {
    public static void main(String[] args) throws Exception {
        // 1.创建消费者，并指定组名
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("tran_group_consumer");
        // 2.连接nameserver
        consumer.setNamesrvAddr("127.0.0.1:9876");
        // 3.订阅主题
        consumer.subscribe("tran", "hello");
        // 4.监听消息
        consumer.registerMessageListener((List<MessageExt> list, ConsumeConcurrentlyContext context) -> {
                    for (MessageExt message : list) {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }
                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                }
        );
        // 5.启动
        consumer.start();
    }
}
```

###### 监听器

```Java
public class MyTranListener implements TransactionListener {
    // 事务原理图里面3、4步的事-执行本地事务
    @Override
    public LocalTransactionState executeLocalTransaction(Message message, Object o) {
        //执行本地事务的代码
        System.out.println("事务保存成功！");
        //返回成功
        return LocalTransactionState.COMMIT_MESSAGE;
    }
    // 此方法就是当我们成功的时候一直没有响应，那么MQ主动来掉这个方法进行回查
    @Override
    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
        //回查的代码,发现本地事务执行成功了的话就返回成功
        System.out.println("回查了事务，发现成功了，我们返回成功！");
        return LocalTransactionState.COMMIT_MESSAGE;//返回成功-需要自己设置
    }
}
```

## ElasticSearch-安装使用---可视kibana

### 理论

全文检索引擎-可以把多个数据表的数据放在es里面

基于Lucene : 

Lucene原理 : 只处理文本,不处理语义.可以处理机构化.非结构化的数据

核心 : 

​	索引创建 : [添加索引-分词-词态转换-排序-合并去重形成倒排索引]   1.原始数据添加索引 .    2.将文本数据进行分词,分词后的数据享有原有索引 .    3.转小写,词态转换 .  (中文的话需要用到中文的分词器)   4.排序 .    5.合并去重形成倒排索引

​	索引搜索 : [判断分词-关键字索引找索引文件-找到数据]   1.关键字判断是否需要分词,   2.根据关键字的索引去找索引文件,   3.根据索引找到原始数据,根据占比进行排序



### es的安装 : (解压即安装)

es的安装 : 解压即安装 elasticsearch-6.8.6.tar

elasticsearch.bat 双击66启动

1-解压到一个文件夹 (就安装好了) 可以双击启动了 [9300-Java代码使用  9200-http连接使用]

添加 - 浏览器使用: postman     PUT : http://127.0.0.1:9200/pethome/pet/1

```Java
{
"id":1,
"name":"柯基"
}
```

获取 浏览器使用 ; postman GET : http://127.0.0.1:9200/pethome/pet/1

设置: es默认内存是1G 我们可以设置小一点,防止内存过大,瓦调

文件,config文件下面的 jvm.options

原来是

```
## - Xms4G
## - Xmx4G
```

改为

```
- Xms512m
- Xmx512m
```



es可视化平台 ; kibana 

kibana-6.8.6-windows-x86_64

 必须和es的版本一致才能使用

kibana=5601解压 即安装

如果要修改端口号: config文件里面的 kibana.yml文件

```
28行如下,放开 设置链接的es端口号
#elasticSearch.hosts: ["http://localhost:9200"]
```

### Ik分词器

elasticsearch-analysis-ik-6.8.6

[可以根据中文语义进行分词]

安装IK分词器----解压放到es的安装文件夹下面的 plugins文件里面  命名为ik就可



### 普通Java整合es

### 普通spring整合es

### springboot整合es 6.8.6

#### 第一步 : 导入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.elasticsearch.client</groupId>
        <artifactId>transport</artifactId>
        <version>6.8.6</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
```

#### 第二步 : 工具包

```Java
public class ESClientUtil {

    public static TransportClient getClient(){
        TransportClient client = null;
        Settings settings = Settings.builder().put("cluster.name", "elasticsearch").build();
        try {
            client = new PreBuiltTransportClient(settings).addTransportAddress(new TransportAddress(InetAddress.getByName("127.0.0.1"), 9300)); //端口号
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
        return client;
    }
}
```

#### 使用:ES的基础

```Java
    //新增
	@Test
    public void testAdd() throws Exception {
        // 1.获取到ES核心对象
        TransportClient client = ESClientUtil.getClient();
        IndexRequestBuilder builder = client.prepareIndex("pethome", "pet", "1");
        HashMap<String, Object> map = new HashMap<>();
        map.put("id", 1);
        map.put("name", "柯基");
        map.put("age", 8);
        map.put("sex", 1);
        IndexResponse response = builder.setSource(map).get();
        System.out.println(response);
    }
```

```Java
   //获取
   @Test
    public void testGet() throws Exception {
        // 1.获取到ES核心对象
        TransportClient client = ESClientUtil.getClient();
        GetRequestBuilder builder = client.prepareGet("pethome", "user", "2");
        Map<String, Object> source = builder.get().getSource();
        System.out.println(source);
        client.close();
    }
```

```Java
//修改
	@Test
    public void testUpdate() throws Exception {
        // 1.获取到ES核心对象
        TransportClient client = ESClientUtil.getClient();
        UpdateRequestBuilder update = client.prepareUpdate("pethome", "pet", "1");
        HashMap<String, Object> map = new HashMap<>();
        map.put("name", "金毛");
        UpdateResponse response = update.setDoc(map).get();
        System.out.println(response);
    }
```

```Java
//删除
@Test
    public void testDelete() throws Exception {
        // 1.获取到ES核心对象
        TransportClient client = ESClientUtil.getClient();
        DeleteRequestBuilder builder = client.prepareDelete("pethome", "pet", "1");
        DeleteResponse response = builder.get();
        System.out.println(response);
    }
```

```Java
 /** - 查询用户表---条件查询
    - name包含：我在源码
    - age在1~12之间
    - 每页大小2
    - 从二页开始查
    - 按照age倒序
    - sex=1
    * */
    @Test
    public void testComplex() throws Exception {
        // 1.获取到ES核心对象
        TransportClient client = ESClientUtil.getClient();
        // 你可以查询多个index
        SearchRequestBuilder builder = client.prepareSearch("pethome");
        // 一个方法要求我们传递一个接口，你有几种方式：1.最瓦的：匿名内部类 2.接口自己的子类 3.以后找接口的对应工具类
        // 得到组合查询对象
        BoolQueryBuilder query = QueryBuilders.boolQuery();
        // 模糊查询==查询的字段
        query.must(QueryBuilders.matchQuery("name", "我在源码"));

        // 等值查询
        query.filter(QueryBuilders.rangeQuery("age").gte(1).lte(12))
                        .filter(QueryBuilders.termQuery("sex", 1));

        builder.setQuery(query);

        // 添加分页条件 from=2 size=2
        builder.setFrom(2); //第几页
        builder.setSize(2); //每页显示条数
        // 添加排序
        SearchResponse response = builder.addSort("age", SortOrder.DESC).get();

        // 得到查询结果
        SearchHit[] hits = response.getHits().getHits();
        for (SearchHit hit : hits) {
            System.out.println(hit.getSourceAsMap());   //getSourceAsMap==把结果集转为map
        }

    }
```

```Java
 /**
     * @Description: 批量添加数据    注意:需要删除pethome 不然查不到
     * @Author: 笔上人间
     * @Date: 2022/7/23 0:02
     * @return: void
     **/
    @Test
    public void testBatch() throws Exception {
        // 1.获取ES连接
        TransportClient client = ESClientUtil.getClient();
        // 2.创建批量操作对象
        BulkRequestBuilder bulk = client.prepareBulk();
        // 3.批量创建文档，放入批量操作对象中
        for (int i = 2; i < 100; i++) {
            IndexRequestBuilder builder = client.prepareIndex("pethome", "user", i + "").setSource(
                    XContentFactory.jsonBuilder()
                            .startObject()     //开始添加数据
                            .field("id", i - 1)
                            .field("name", "我在源码学习Java!" + i)
                            .field("age", i - 1)
                            .field("sex", i%2)
                            .endObject()      //结束添加数据
            );
            BulkResponse result = bulk.add(builder).get();
            System.out.println(result.status());
        }
    }


```

## seata

### seata安装 : 

seata-server-1.1.0解压即安装

## Sentinel-阿里的-限流熔断

### 安装

sentinel-dashboard-1.7.1.jar

把这个包放在你想要装的位置

新建一个文件 sentinel.bat

```
java -jar -Dserver.port=1111 sentinel-dashboard-1.7.1.jar
```

# Springmvc改为Springboot项目

## 删除原来的依赖: 如下   

```xml
    
<!-- Spring依赖 -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aop</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-beans</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>commons-logging</groupId>
      <artifactId>commons-logging</artifactId>
      <version>1.2</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-expression</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>


   <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-core</artifactId>
      <version>1.3</version>
      <scope>test</scope>
    </dependency>


    <!-- mybatis依赖 -->
    <dependency>
      <groupId>org.mybatis  </groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.3</version>
    </dependency>
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.17</version>
    </dependency>

    <!-- mybatis与spring整合依赖 -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.1</version>
    </dependency>

    <!-- 数据库驱动和连接池 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.16</version>
    </dependency>
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-dbcp2</artifactId>
      <version>2.1.1</version>
    </dependency>
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-pool2</artifactId>
      <version>2.4.2</version>
    </dependency>
    <!-- SpringMVC依赖 -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>4.0.1</version>
      <scope>provided</scope>
    </dependency>
    <!-- JSTL表达式 -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>
    <dependency>
      <groupId>taglibs</groupId>
      <artifactId>standard</artifactId>
      <version>1.1.2</version>
    </dependency>

    <!-- jackson依赖 -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.8</version>
    </dependency>

    <!-- 上传下载 -->
    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.3.2</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>5.0.8.RELEASE</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-juli -->
    <dependency>
      <groupId>org.apache.tomcat</groupId>
      <artifactId>tomcat-juli</artifactId>
      <version>7.0.92</version>
    </dependency>
  <build>
    <finalName>wuliu</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>8</source>
          <target>8</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

## 加入springboot 爹依赖==== 添加在 dependencies外面

```xml
    <!--SpringBoot父子项目基础依赖-->
    <parent>
        <groupId> org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.5.RELEASE</version>
    </parent>


    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
    </dependency>

  <!-- SpringBoot2.2.5默认的mysql是mysql8。所有手动降级为mysql5 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.38</version>
        </dependency>

        <!-- spring与mybatis整合包 -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.1.1</version>
        </dependency>



```

## 添加一个启动类

```Java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.ambow.dao")
public class WuLiuApp {
    public static void main(String[] args) {
        SpringApplication.run(WuLiuApp.class);
    }
}

```

## 再 加一个xml     :   application.yml

```yml
server:
  port: 8080

spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql:///ttwuliu?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8
    username: root
    password: 123456
mybatis:
  type-aliases-package: com.ambow.entity


```

applicationContext.xml 
db.properties 
log4j.properties 
springmvc-config.xml 
webapp

删掉

前段的这个是对应后端的端口号

```
target: 'http://localhost:8081',     //代理的目标地址
```

# stream流式编程

```Java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Apple {
    private Integer id;
    private String Color;
    private Integer weight;
    private String origin;
}
```

## 1

```Java
/**
 * 测试类
 */
public class Class001 {
    //定义一个装对象的集合
    private static List<Apple> appleArrayList = new ArrayList<>();
    //往这个集合里面添加对象,并且赋值
    static {
        appleArrayList.add(new Apple(1, "红色", 100, "绵阳"));
        appleArrayList.add(new Apple(2, "橙色", 200, "绵阳"));
        appleArrayList.add(new Apple(3, "黄色", 300, "绵阳"));
        appleArrayList.add(new Apple(4, "绿色", 400, "南充"));
        appleArrayList.add(new Apple(5, "蓝色", 500, "南充"));
        appleArrayList.add(new Apple(6, "靛色", 600, "南充"));
        appleArrayList.add(new Apple(7, "紫色", 700, "南充"));
        appleArrayList.add(new Apple(8, "红色", 100, "南充"));
        appleArrayList.add(new Apple(9, "橙色", 200, "成都"));
        appleArrayList.add(new Apple(10, "黄色", 300, "成都"));
        appleArrayList.add(new Apple(11, "绿色", 400, "成都"));
        appleArrayList.add(new Apple(12, "蓝色", 500, "成都"));
        appleArrayList.add(new Apple(13, "靛色", 600, "北京"));
        appleArrayList.add(new Apple(14, "紫色", 700, "北京"));
    }

    /**
     * 找出红色的苹果-放进一个集合里面
     */
    //写法一[正常写]
    @Test
    public void test() {
        ArrayList<Apple> apples = new ArrayList<>();
        for (Apple apple : appleArrayList) {
            //循环判断颜色是否为红色,如果为红色就输出
            if (apple.getColor().equals("红色")) {
                apples.add(apple);
                System.out.println(apple.toString());
            }
        }
    }
    //Stream流式写法
    @Test
    public void test2() {
        //遍历这个集合,根据条件对应的对象转为对应的集合
        //把这个集合里面的颜色为红色的对象们转为一个新的集合
        List<Apple> redappples = appleArrayList.stream().filter(a -> a.getColor().equals("红色")).collect(Collectors.toList());
        //遍历打印新的集合
        redappples.forEach(apple -> System.out.println(apple));
    }

    /**
     * 找出红色的苹果
     * 并且重量是500
     * 产地是绵阳
     */
    //写法一[正常写]
    @Test
    public void test3() {
        ArrayList<Apple> apples = new ArrayList<>();
        for (Apple apple : appleArrayList) {
            //循环判断颜色是否为红色,如果为红色就输出
            if (apple.getColor().equals("红色") && apple.getWeight().equals(100) && apple.getOrigin().equals("绵阳")){
                apples.add(apple);
                System.out.println(apple.toString());
            }
        }
    }
    //Stream流式写法一
    @Test
    public void test4() {
        //遍历这个集合,根据条件对应的对象转为对应的集合
        List<Apple> redappples = appleArrayList.stream().filter(a -> a.getColor().equals("红色")).filter(a->a.getWeight().equals(100)).collect(Collectors.toList());
        redappples.forEach(apple -> System.out.println(apple));
    }
     //Stream流式写法二
    //定义一个stream流的方法-需要传入条件
    @Test
    public void test4(Predicate<? super Apple> pr) {
        //遍历这个集合,根据条件对应的对象转为对应的集合
        List<Apple> redappples = appleArrayList.stream().filter(pr).collect(Collectors.toList());
        redappples.forEach(apple -> System.out.println(apple));
    }
    //调用上面的方法,传入自定义条件
    public static void main(String[] args) {
        new Class001().test4(apple -> apple.getColor().equals("红色")
                && apple.getWeight()>99
        );
    }
    /**
     * 求出每个颜色的苹果的平均重量
     */
    //以前的普通写法
    @Test
    public void test5(){
        int count = 0;
        //基于颜色分
        // 组
        Map<String, List<Apple>> appmap = new HashMap<>();
        for (Apple apple : appleArrayList) {
            //分组-先用不同的颜色为KEY创建集合[如果这个颜色的集合不存在,那么我们就会创建一个集合]
            List<Apple> list = appmap.computeIfAbsent(apple.getColor(),Key-> new ArrayList<>());
            list.add(apple);
        }
        for (Map.Entry<String, List<Apple>> stringListEntry : appmap.entrySet()) {
            for (Apple apple : stringListEntry.getValue()) {
                count+=apple.getWeight();
            }
            //平均重量
            System.out.println(stringListEntry.getKey()+" 均价="+count/stringListEntry.getValue().size());
            count = 0;
        }
    }
    //stream流的写法
    @Test
    public void test6(){
        appleArrayList.stream().collect(Collectors.groupingBy(a->a.getColor(),//基于颜色分组
                Collectors.averagingInt(a->a.getWeight())))//求平均值
                .forEach((k,v)-> System.out.println((k+"="+v)));//打印
    }
}

```

# 项目五

# 项目六

## 项目搭建 : 

新建父子项目  ,  删除src  

### 导入父依赖 : 

```xml
<!--    1. 打包方式-->
    <packaging>pom</packaging>
<!--    2. Springboot-->
    <parent>
        <groupId> org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.5.RELEASE</version>
    </parent>
<!--    3. springcloud依赖-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.2.1.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.SR3</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
<!--    4. 公共配置-->
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
        <ymcc.version>1.0-SNAPSHOT</ymcc.version>
    </properties>
<!--    5.公共依赖-->
    <!--公共的依赖-->
    <dependencies>
        <!--        小辣椒-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!--阿里巴巴-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.50</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
    </dependencies>
```

###  项目结构 : 

```
itsource-ymcc    --------------------------------    
	itsource-basic    --------------------------    
		itsource-basic-common    --------------- 基础模块    
		itsource-gen-code    -------------------    
	ymcc-api    --------------------------------    
		ymcc-api-course    ---------------------    
		ymcc-api-media    ----------------------    
		ymcc-api-order    ----------------------    
		ymcc-api-search	  ----------------------
		ymcc-api-system    ---------------------    
		ymcc-api-uaa    ------------------------    
	ymcc-basic    ------------------------------    
		ymcc-basic-common    -------------------  用来存放常用的工具  
		ymcc-basic-dependency    ---------------  用来存放公共的依赖  
		ymcc-basic-uaa    ----------------------    
	ymcc-pojo    -------------------------------    
		ymcc-pojo-common    --------------------    
		ymcc-pojo-course    --------------------    
		ymcc-pojo-kill    ----------------------    
		ymcc-pojo-media    ---------------------    
		ymcc-pojo-order    ---------------------    
		ymcc-pojo-pay    -----------------------    
		ymcc-pojo-search    --------------------    
		ymcc-pojo-system    --------------------    
		ymcc-pojo-uaa    -----------------------    
		ymcc-pojo-user    ----------------------    
	ymcc-service    ----------------------------    
		ymcc-service-common    -----------------    
		ymcc-service-course    -----------------    
		ymcc-service-kill    -------------------    
		ymcc-service-media    ------------------    
		ymcc-service-order    ------------------    
		ymcc-service-pay    --------------------    
		ymcc-service-search    -----------------  
	ymcc-ui    --------------------------------- 前段
    	ymcc-ui-course    ---------------------- 门户课程站点
    	ymcc-ui-system    ---------------------- 系统管理前端
    	ymcc-ui-user    ------------------------ 门户用户系统
```

​	启动nacos :  安装看其他 

### gateway :  

--------------------------------------------------------------服务端-------------------------------------------------------------

#### 第一步 导入依赖 ; 

```xml
<dependencies>
<!--    gateway服务端依赖-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <!--        导入config配置中心依赖-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>

    <!-- 服务注册与发现-->
    <dependency>
        <groupId>com.alibaba.cloud </groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
</dependencies>


```

#### 启动类 增加：@EnableDiscoveryClient 注册到Nacos

```Java
/**
 * 网管启动类
 */
@SpringBootApplication
@EnableDiscoveryClient      //nacos服务端和客服端都写上
public class GatewayStarter {
    public static void main(String[] args) {
        SpringApplication.run(GatewayStarter.class);
    }
}
```



#### 云端gateway yaml配置

服务基础配置：服务名，端口注册到Nacos配置gateay路由配置Nacos配置管理跨域配置

```yaml
server:
  port: 11000
spring:
  application:
    name: service-gateway #服务名
  cloud: #注册到Nacos
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    gateway:
      discovery:
        locator:
          enabled: false #开放服务名访问方式
          lower-case-service-id: true #服务名小写
      routes: #路由配置
        - id : application-user #指定服务名
          uri: lb://service-user #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/user/**	#服务访问路径
          filters:
            - StripPrefix=2	
        - id: application-uaa #指定服务名
          uri: lb://service-uaa #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/uaa/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-course #指定服务名
          uri: lb://service-course #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/course/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-system #指定服务名
          uri: lb://service-system #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/system/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-search #指定服务名
          uri: lb://service-search #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/search/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-pay #指定服务名
          uri: lb://service-pay #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/pay/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-order #指定服务名
          uri: lb://service-order #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/order/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-media #指定服务名
          uri: lb://service-media #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/media/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-kill #指定服务名
          uri: lb://service-kill #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/kill/**    #服务访问路径
          filters:
            - StripPrefix=2
        - id: application-common #指定服务名
          uri: lb://service-common #去注册中心找这个服务名
          predicates:    #断言，匹配访问的路径
            - Path=/ymcc/common/**    #服务访问路径
          filters:
            - StripPrefix=2
      globalcors: #跨域配置
        cors-configurations:
          '[/**]':
            allowedOrigins: "*"
            allow-credentials: true
            allowed-headers: "*"
            allowedMethods:
              - GET
              - POST
              - DELETE
              - PUT
              - PATCH
              - OPTIONS
              - HEAD
              - CONNECT
              - TRACE
  #允许Bean覆盖
  main:
    allow-bean-definition-overriding: true
```

#### bootstrap.yml

```
spring:
  profiles:
    active: dev
  cloud:
    nacos:
      config:
        server-addr: localhost:8848     #配置中心
        file-extension: yaml            #配置文件的后缀
        prefix: application-gateway     #   这个是Data ID的前缀  配置前缀 ，默认使用sring.application.name
        group: DEFAULT_GROUP            # 默认分组
        namespace: 46b587d0-b34b-4996-a2d3-9c450dd98cd4     #指定名称空间id
```

-------------------------------------------------------------客户端 -------------------------------------------------------------

#### 客户端依赖 : 

```xml
<dependencies>
    <!--    web依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--        导入config配置中心依赖-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>

    <!-- 服务注册与发现-->
    <dependency>
        <groupId>com.alibaba.cloud </groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
</dependencies>
```

#### 启动类 

```Java
/**
 * 网管启动类
 */
@SpringBootApplication
@EnableDiscoveryClient      //nacos服务端和客服端都写上
public class GatewayStarter {
    public static void main(String[] args) {
        SpringApplication.run(GatewayStarter.class);
    }
}

```

#### application.yml

```yml
server:
  port: 10020

spring:
  application:
    name: service-system        #name去网管cv名字

  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848

```

#### bootstrap.yml  

--- 这里只是写了这个文件,但是用的配置文件还是本地的

```
spring:
  profiles:
    active: dev
  cloud:
    nacos:
      config:
        server-addr: localhost:8848     #配置中心
        file-extension: yaml            #配置文件的后缀
        prefix: application-system     #   这个是Data ID的前缀  配置前缀 ，默认使用sring.application.name
        group: DEFAULT_GROUP            # 默认分组
        namespace: #46b587d0-b34b-4996-a2d3-9c450dd98cd4     #指定名称空间id
```



创建基础模块ymcc-basic-common，拷贝BaseQuery，JSONResult，PageLis 到模块中

## **集成mybatisplus**

###  导入依赖

放在代码生成的那个服务的pom.xml中

```xml
<!--    导入mybatis-plus相关的依赖 start-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>2.2.0</version>
    </dependency>
<!--    模板引擎-->
    <dependency>
        <groupId>org.apache.velocity</groupId>
        <artifactId>velocity-engine-core</artifactId>
        <version>2.0</version>
    </dependency>
<!--    mysql-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
<!--    导入mybatis-plus相关的依赖 end-->

```

### 创建配置

resource/mybatiesplus-config-system.properties

```properties
#代码输出基本路径三层的输出路径
OutputDir=C:/Users/systemistrator/Desktop/java1107/code/ymcc-1107/ymcc-parent/ymcc-system-parent/ymcc-system-server-2010/src/main/java

#mapper.xml SQL映射文件目录
OutputDirXml=C:/Users/systemistrator/Desktop/java1107/code/ymcc-1107/ymcc-parent/ymcc-system-parent/ymcc-system-server-2010/src/main/resources

#domain的输出路径
OutputDirBase=C:/Users/systemistrator/Desktop/java1107/code/ymcc-1107/ymcc-parent/ymcc-system-parent/ymcc-system-common/src/main/java

#设置作者
author=whale.chen

#自定义包路径:基础包的路径
parent=cn.itsource.ymcc

#数据库连接信息
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///ymcc-system?serverTimezone=UTC
jdbc.user=root
jdbc.pwd=123456
```

resource/templates/controller.java.vm

resource/templates/query.java.vm

### 下面放两个文件

#### controller.java.vm

```VM
package ${package.Controller};

import ${package.Service}.${table.serviceName};
import ${package.Entity}.${entity};
import cn.itsource.ymcc.query.${entity}Query;
import cn.itsource.ymcc.result.JSONResult;
import cn.itsource.ymcc.result.PageList;
import com.baomidou.mybatisplus.plugins.Page;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/${table.entityPath}")
public class ${entity}Controller {

    @Autowired
    public ${table.serviceName} ${table.entityPath}Service;

    /**
    * 保存和修改公用的
    */
    @RequestMapping(value="/save",method= RequestMethod.POST)
    public JSONResult saveOrUpdate(@RequestBody ${entity} ${table.entityPath}){
        if(${table.entityPath}.getId()!=null){
            ${table.entityPath}Service.updateById(${table.entityPath});
        }else{
            ${table.entityPath}Service.insert(${table.entityPath});
        }
        return JSONResult.success();
    }

    /**
    * 删除对象
    */
    @RequestMapping(value="/{id}",method=RequestMethod.DELETE)
    public JSONResult delete(@PathVariable("id") Long id){
        ${table.entityPath}Service.deleteById(id);
        return JSONResult.success();
    }

    /**
   * 获取对象
   */
    @RequestMapping(value = "/{id}",method = RequestMethod.GET)
    public JSONResult get(@PathVariable("id")Long id){
        return JSONResult.success(${table.entityPath}Service.selectById(id));
    }


    /**
    * 查询所有对象
    */
    @RequestMapping(value = "/list",method = RequestMethod.GET)
    public JSONResult list(){
        return JSONResult.success(${table.entityPath}Service.selectList(null));
    }


    /**
    * 带条件分页查询数据
    */
    @RequestMapping(value = "/pagelist",method = RequestMethod.POST)
    public JSONResult page(@RequestBody ${entity}Query query){
        Page<${entity}> page = new Page<${entity}>(query.getPage(),query.getRows());
        page = ${table.entityPath}Service.selectPage(page);
        return JSONResult.success(new PageList<${entity}>(page.getTotal(),page.getRecords()));
    }
}

```

#### query.java.vm

```VM
package cn.itsource.ymcc.query;

/**
 *
 * @author ${author}
 * @since ${date}
 */
public class ${table.entityName}Query extends BaseQuery{
}
```



### 代码生成主类

```java
package cn.itsource;

import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.InjectionConfig;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.config.rules.DbType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;

import java.util.*;

/**
 * 生成代码的主类
 */
public class GenteratorCode {

    public static void main(String[] args) throws InterruptedException {
        //用来获取Mybatis-Plus.properties文件的配置信息
        ResourceBundle rb = ResourceBundle.getBundle("mybatiesplus-config-system"); //不要加后缀
        AutoGenerator mpg = new AutoGenerator();
        // 全局配置
        GlobalConfig gc = new GlobalConfig();

        gc.setOutputDir(rb.getString("OutputDir"));
        gc.setFileOverride(false);
        gc.setActiveRecord(true);// 开启 activeRecord 模式
        gc.setEnableCache(false);// XML 二级缓存
        gc.setBaseResultMap(true);// XML ResultMap
        gc.setBaseColumnList(false);// XML columList
        gc.setAuthor(rb.getString("author"));
        mpg.setGlobalConfig(gc);
        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setDbType(DbType.MYSQL);
        dsc.setTypeConvert(new MySqlTypeConvert());
        dsc.setDriverName(rb.getString("jdbc.driver"));
        dsc.setUsername(rb.getString("jdbc.user"));
        dsc.setPassword(rb.getString("jdbc.pwd"));
        dsc.setUrl(rb.getString("jdbc.url"));
        mpg.setDataSource(dsc);
        // 表策略配置
        StrategyConfig strategy = new StrategyConfig();
        strategy.setTablePrefix(new String[] { "t_" });// 此处可以修改为您的表前缀
        strategy.setNaming(NamingStrategy.underline_to_camel);// 表名生成策略

        strategy.setInclude(new String[]{
                "t_config",
                "t_department",
                "t_employee",
                "t_operation_log",
                "t_systemdictionary",
                "t_systemdictionaryitem"
        }); // 需要生成的表

        mpg.setStrategy(strategy);
        // 包配置
        PackageConfig pc = new PackageConfig();
        pc.setParent(rb.getString("parent"));  //cn.itsource.ymcc
        pc.setController("web.controller"); //cn.itsource.ymcc.web.controller
        pc.setService("service");
        pc.setServiceImpl("service.impl");
        pc.setEntity("domain");
        pc.setMapper("mapper");
        mpg.setPackageInfo(pc);

        // 注入自定义配置，可以在 VM 中使用 cfg.abc 【可无】
        InjectionConfig cfg = new InjectionConfig() {
            @Override
            public void initMap() {
                Map<String, Object> map = new HashMap<String, Object>();
                map.put("abc", this.getConfig().getGlobalConfig().getAuthor() + "-rb");
                this.setMap(map);
            }
        };

        List<FileOutConfig> focList = new ArrayList<FileOutConfig>();

        //controller的输出配置
        focList.add(new FileOutConfig("/templates/controller.java.vm") {
            @Override
            public String outputFile(TableInfo tableInfo) {
                //合并好的内容输出到哪儿？
                return rb.getString("OutputDir")+ "/cn/itsource/ymcc/web/controller/" + tableInfo.getEntityName() + "Controller.java";
            }
        });
        //query的输出配置
        focList.add(new FileOutConfig("/templates/query.java.vm") {
            @Override
            public String outputFile(TableInfo tableInfo) {
                return rb.getString("OutputDirBase")+ "/cn/itsource/ymcc/query/" + tableInfo.getEntityName() + "Query.java";
            }
        });

        // 调整 domain 生成目录演示
        focList.add(new FileOutConfig("/templates/entity.java.vm") {
            @Override
            public String outputFile(TableInfo tableInfo) {
                return rb.getString("OutputDirBase")+ "/cn/itsource/ymcc/domain/" + tableInfo.getEntityName() + ".java";
            }
        });

        // 调整 xml 生成目录演示
        focList.add(new FileOutConfig("/templates/mapper.xml.vm") {
            @Override
            public String outputFile(TableInfo tableInfo) {
                return rb.getString("OutputDirXml")+ "/cn/itsource/ymcc/mapper/" + tableInfo.getEntityName() + "Mapper.xml";
            }
        });
        cfg.setFileOutConfigList(focList);
        mpg.setCfg(cfg);

        // 自定义模板配置，可以 copy 源码 mybatis-plus/src/main/resources/templates 下面内容修改，
        // 放置自己项目的 src/main/resources/templates 目录下, 默认名称一下可以不配置，也可以自定义模板名称
        TemplateConfig tc = new TemplateConfig();
        tc.setService("/templates/service.java.vm");
        tc.setServiceImpl("/templates/serviceImpl.java.vm");
        tc.setMapper("/templates/mapper.java.vm");
        tc.setEntity(null);
        tc.setController(null);
        tc.setXml(null);
        // 如上任何一个模块如果设置 空 OR Null 将不生成该模块。
        mpg.setTemplate(tc);

        // 执行生成
        mpg.execute();
    }
}
```

### 然后每一个domain实体类对应的类都要导一个依赖,建议提出来公用

```xml
<!--        mybatis-plus实体类需要的依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-support</artifactId>
            <version>2.2.0</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
```

### controller三成还需要加

```xml
<!--    数据库链接依赖-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
<!--    druid依赖-->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.9</version>
    </dependency>
```

### yml

```Java
spring:
  datasource:      #mybatis链接数据库相关
    url: jdbc:mysql:///ymcc-system?serverTimezone=UTC          #数据库和时区
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
mybatis-plus:                   #扫描mapper文件---这个顶格放不放Spring下面    配置别名
    mapper-locations: classpath:cn/itsource/ymcc/mapper/*Mapper.xml
```

### 配置类 ymcc.config 加一个config  /   MybatisPlusConfig

```Java
@Configuration
//mapper接口扫描
@MapperScan("cn.itsource.ymcc.mapper")
//事务管理
@EnableTransactionManagement  
public class MybatisPlusConfig {

    /**
     * 分页插件
     */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
}
```

### mybatisplus添加构造器

https://blog.csdn.net/qq_49137582/article/details/125121556

## 集成swagger

### 1.依赖

有两种方法.微服务集成和单独集成

微服务需要swagger聚合

因为没一个service都要用swagger 

所以可以放在公共的配置里面

```xml
<!--引入swagger支持-->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>
```

### 2.配置一个配置类

每一个service里面都需要一个配置类

```Java
@Configuration
@EnableSwagger2
public class Swagger2Config {
 
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                //对外暴露服务的包,以controller的方式暴露,所以就是controller的包.
                .apis(RequestHandlerSelectors.basePackage("cn.itsource.ymcc.web.controller"))
                .paths(PathSelectors.any())
                .build();
    }
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("管理系统")      
                .description("管理系统接口文档说明")
                .contact(new Contact("whale.chen", "", "whale.chen@itsource.cn"))
                .version("1.0")
                .build();
    }
//Contact   需要导一个包.最长的那个 
}
```

测试 /swagger-ui.html  即可

### Gateway聚合swagger

geteway : 下面放的依赖

```xml
<!--   Gateway聚合swagger -->
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger2</artifactId>
        <version>2.9.2</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger-ui</artifactId>
        <version>2.9.2</version>
    </dependency>
```

gateway有两个配置类

```Java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import springfox.documentation.swagger.web.*;

import java.util.Optional;

@RestController
@RequestMapping("/swagger-resources")
public class SwaggerHandler {

    @Autowired(required = false)
    private SecurityConfiguration securityConfiguration;

    @Autowired(required = false)
    private UiConfiguration uiConfiguration;

    private final SwaggerResourcesProvider swaggerResources;
 
    @Autowired
    public SwaggerHandler(SwaggerResourcesProvider swaggerResources) {
        this.swaggerResources = swaggerResources;
    }
 
 
    @GetMapping("/configuration/security")
    public Mono<ResponseEntity<SecurityConfiguration>> securityConfiguration() {
        return Mono.just(new ResponseEntity<>(
                Optional.ofNullable(securityConfiguration).orElse(SecurityConfigurationBuilder.builder().build()), HttpStatus.OK));
    }
 
    @GetMapping("/configuration/ui")
    public Mono<ResponseEntity<UiConfiguration>> uiConfiguration() {
        return Mono.just(new ResponseEntity<>(
                Optional.ofNullable(uiConfiguration).orElse(UiConfigurationBuilder.builder().build()), HttpStatus.OK));
    }
 
    @GetMapping("")
    public Mono<ResponseEntity> swaggerResources() {
        return Mono.just((new ResponseEntity<>(swaggerResources.get(), HttpStatus.OK)));
    }
}
```

```Java

import lombok.AllArgsConstructor;
import org.springframework.cloud.gateway.config.GatewayProperties;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.support.NameUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;
import org.springframework.web.util.UriComponentsBuilder;
import springfox.documentation.PathProvider;
import springfox.documentation.spring.web.paths.Paths;
import springfox.documentation.swagger.web.SwaggerResource;
import springfox.documentation.swagger.web.SwaggerResourcesProvider;

import java.util.ArrayList;
import java.util.List;

@Component
@Primary
@AllArgsConstructor
public class SwaggerProvider implements SwaggerResourcesProvider {
    public static final String API_URI = "/v2/api-docs";
    private final RouteLocator routeLocator;
    private final GatewayProperties gatewayProperties;


    @Override
    public List<SwaggerResource> get() {
        List<SwaggerResource> resources = new ArrayList<>();
        List<String> routes = new ArrayList<>();
        routeLocator.getRoutes().subscribe(route -> routes.add(route.getId()));
        gatewayProperties.getRoutes().stream().filter(routeDefinition -> routes.contains(routeDefinition.getId()))
                .forEach(routeDefinition -> routeDefinition.getPredicates().stream()
                        .filter(predicateDefinition -> ("Path").equalsIgnoreCase(predicateDefinition.getName()))
                        .forEach(predicateDefinition -> resources.add(swaggerResource(routeDefinition.getId(),
                                predicateDefinition.getArgs().get(NameUtils.GENERATED_NAME_PREFIX + "0")
                                        .replace("/**", API_URI)))));
        return resources;
    }

    private SwaggerResource swaggerResource(String name, String location) {
        SwaggerResource swaggerResource = new SwaggerResource();
        swaggerResource.setName(name);
        swaggerResource.setLocation(location);
        swaggerResource.setSwaggerVersion("2.0");
        return swaggerResource;
    }
}
```

## 统一异常处理

可以使用@ControllerAdvice注解，编写一个全局异常处理类***，再自定义一个方法***使用@ExceptionHandler来捕获具体的异常并作相应的处理
通常情况下后台向前台返回结果时，会把结果封装成包含有错误码，错误信息以及数据本身的json数据，因此我们可以使用自定义异常类，自定义枚举错误码，在捕获全局异常后，向前台返回一个包含错误码的信息

### 统一异常处理.枚举封装

使用@ControllerAdvice编写一个全局异常处理类

异常的包名必须好服务的额包名一致

例如 :  都在cn.itsource.ymcc下面

全局异常类.可以写在公共的组件里面.因为你他每一个服务都可以用

1.依赖

```xml
单独定义全局异常的话就使用单独的
<!--    <dependency>-->
<!--        <groupId>org.springframework</groupId>-->
<!--        <artifactId>spring-web</artifactId>-->
<!--    </dependency>-->

或者就这个
<!--    &lt;!&ndash;定义全局异常需要的依赖&ndash;&gt;-->
<!--    <dependency>-->
<!--        <groupId>org.springframework</groupId>-->
<!--        <artifactId>spring-web</artifactId>-->
<!--    </dependency>-->
<!--    &lt;!&ndash;spring-boot-validation依赖&ndash&ndash;&gt;-->
<!--    <dependency>-->
<!--        <groupId>org.springframework.boot</groupId>-->
<!--        <artifactId>spring-boot-starter-validation</artifactId>-->
<!--    </dependency>-->

    <!--spring-boot-web依赖:这个里面有定义全局异常需要的依赖+spring-boot-validation依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
```

测试的代码

```Java
        if(id==1){//测试异常的代码
            //创建一个自定义异常,里面的值是枚举封装的数据
            throw new GlobalCustomException(GlobalEnumCode.TEST1_ERROR.getErrorMessage(),GlobalEnumCode.TEST1_ERROR.getErrorCode());
        }
        if(id==2){//测试异常的代码
            //创建一个自定义异常,里面的值是枚举封装的数据
            throw new GlobalCustomException(GlobalEnumCode.TEST_ERROR.getErrorMessage(),GlobalEnumCode.TEST_ERROR.getErrorCode());
        }
        if(id==3){//测试异常的代码
            //创建一个自定义异常,里面的值是枚举封装的数据
            throw new GlobalCustomException(GlobalEnumCode.CODE_EXPIRED_ERROR.getErrorMessage(),GlobalEnumCode.CODE_EXPIRED_ERROR.getErrorCode());
        }
```

2.定义搜索全局异常的类

```Java
/**
 * 全局异常处理的类---异常执行二
 */
@RestControllerAdvice
@Component
@Slf4j
public class GlobalException {

    @ExceptionHandler(Exception.class) //此注解标识当前方法捕捉的异常类型    最大捕获异常
    public JSONResult exceptionHandler(Exception e ){
        e.printStackTrace();
        log.info("捕捉了exception异常");
        String errorMessage = GlobalEnumCode.TEST_ERROR.getErrorMessage();
        String errorCode = GlobalEnumCode.TEST_ERROR.getErrorCode();
        return JSONResult.error(errorMessage,errorCode);
    }

    /**
     * 指定捕获异常.当异常不符合该异常类型的时候就走上面的捕获最大的异常方法
     * @param e
     * @return
     */
    @ExceptionHandler(GlobalCustomException.class) //此注解标识当前方法捕捉的异常类型  捕捉我们的自定义异常  指定捕获异常
    public JSONResult exceptionHandler (GlobalCustomException e ){//这里传过来的是我们的自定义异常
        e.printStackTrace();
        log.info("捕捉了exception异常");
        log.info(e.getErrorMessage()+e.getErrorCode());
        return JSONResult.error(e.getErrorMessage(),e.getErrorCode());//把我们的自定义异常的信息传到JSONResult.进行返回
    }
}
```

3.定义自定义异常类

```Java
/**
 * 自定义异常
 */

import cn.itsource.enums.GlobalEnumCode;
import lombok.Data;

/**
 * 自定义异常类   执行异常 一
 */
@Data
public class GlobalCustomException extends RuntimeException{

    private String errorMessage;
    private String errorCode;

    public GlobalCustomException(){
        super();
    }
    public GlobalCustomException(String message){
        //交给父类RuntimeException
        super(message);
    }

    //自定义异常参数的有参构造
    public GlobalCustomException(String errorMessage,String errorCode){
        super(errorMessage);
        this.errorMessage = errorMessage;
        this.errorCode = errorCode;
    }

    /**
     * 自定义枚举异常的有参构造   GlobalCustomException(GlobalEnumCode.PARAN_IS_NULL_ERROR);
     * @param globalEnumCode
     */
    public GlobalCustomException(GlobalEnumCode globalEnumCode){
        //这个暂时用不到
        super(globalEnumCode.getErrorMessage());

        this.errorMessage = globalEnumCode.getErrorMessage();
        this.errorCode = globalEnumCode.getErrorCode();
    }
}
```

4.枚举封装

```Java

/**
 * 枚举封装异常类  异常执行 三
 */
public enum GlobalEnumCode {
    //成功
    OK("成功","0"),

    //失败
    ERROR("我们正在抢救程序员,请稍后重试","-1"),

    //测试使用的枚举
    TEST_ERROR("测试的错误","500"),

    //公共异常以100xx开头
    PARAN_IS_NULL_ERROR("参数不能为空","10001"),

    //测试使用的枚举
    TEST_ERROR("测试的错误","500"),
    TEST1_ERROR("测试的成功","200"),

    //system异常以200xx开头

    //user异常以300xx开头
    USER_EXISTED_ERROR("用户已存在！","30001"),
    USER_REGISTER_ERROR("用户注册失败！","30002"),
    USER_BALICK_ERROR("用户已经被拉黑！","30002"),

    //common异常以500开头
    // common服务异常以500XX开头
    PHONE_IS_NULL_ERROR("手机号不能为空！","50001"),
    INTERVAL_ERROR("时间未过一分钟，请勿重复获取验证码！ ","50002"),
    PHONE_FORMAT_ERROR("手机格式不正确！", "50003"),
    CODE_EXPIRED_ERROR("验证码已过期！", "50004"),
    CODE_INCORRECT_ERROR("验证码不正确！", "50005"),



    // course服务异常以600XX开头
    COURSE_EXISTED_ERROR("课程已存在！", "60001");

    private String errorMessage;
    private String errorCode;
    //需要getter方法和有参构造方法   --只能让你拿.不能让你修改

    GlobalEnumCode(String errorMessage, String errorCode) {
        this.errorMessage = errorMessage;
        this.errorCode = errorCode;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```



### 哔哩哔哩上学的全局异常处理的方法

```Java
@RestControllerAdvice
public class GlobalExceptionAdvice {

    //如果说你现在是一个包含有完整的项目需求的项目,可以在此处填写上一些自定义的业务异常
    @ResponseBody   //本次的处理是基于rest风格完成的
    @ExceptionHandler(Exception.class)//用于捕获的类型--所有的异常全部收入囊中
    public Object exceptionHandler(Exception e){//实现所有的异常处理类
        HashMap<String, Object> map = new HashMap<>();
        map.put("异常信息",e.getMessage());//直接获取异常信息
        map.put("状态码", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);//设置一个状态码
        map.put("异常的类型",e.getClass().getName());//获取异常的类型
        //获取到请求的路径
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        map.put("异常发生时的请求路径",request.getRequestURL());//异常发生时的请求路径
        return map;//直接返回对象
    }

```

## JSR303判断 ;

```Java
@Null	//验证对象是否为null
@NotNull	//验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank	//检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty	//检查约束元素是否为NULL或者是EMPTY.

Booelan检查
@AssertTrue	//验证 Boolean 对象是否为 true
@AssertFalse	//验证 Boolean 对象是否为 false

长度检查	 
@Size(min=, max=)	//验证对象（Array,Collection,Map,String）长度是否在给定的范围之内
@Length(min=, max=)	//Validates that the annotated string is between min and max included.

日期检查	 
@Past	//验证 Date 和 Calendar 对象是否在当前时间之前
@Future	//验证 Date 和 Calendar 对象是否在当前时间之后
@Pattern	//验证 String 对象是否符合正则表达式的规则

数值检查	//建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为"",Integer为null
@Min	//验证 Number 和 String 对象是否大等于指定的值
@Max	//验证 Number 和 String 对象是否小等于指定的值
@DecimalMax	//被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度
@DecimalMin	//被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度
@Digits	//验证 Number 和 String 的构成是否合法
@Digits(integer=,fraction=)	//验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。

@Range(min=, max=)	//检查数字是否介于min和max之间.
@Range(min=10000,max=50000,message=“range.bean.wage”)	private BigDecimal wage;

@Valid	//递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)
@CreditCardNumber	//信用卡验证
@Email	//验证是否是邮件地址，如果为null,不进行验证，算通过验证。
@ScriptAssert(lang= ,script=, alias=)	 
@URL(protocol=,host=, port=,regexp=, flags=)
```

### 1.导入依赖

如果异常处理用的大的那个依赖.那么就不需要在导了

```xml
单独定义全局异常的话就使用单独的
<!--    <dependency>-->
<!--        <groupId>org.springframework</groupId>-->
<!--        <artifactId>spring-web</artifactId>-->
<!--    </dependency>-->

或者就这个
<!--    &lt;!&ndash;定义全局异常需要的依赖&ndash;&gt;-->
<!--    <dependency>-->
<!--        <groupId>org.springframework</groupId>-->
<!--        <artifactId>spring-web</artifactId>-->
<!--    </dependency>-->

<!--    &lt;!&ndash;spring-boot-validation依赖Jsr303使用;-->
<!--    <dependency>-->
<!--        <groupId>org.springframework.boot</groupId>-->
<!--        <artifactId>spring-boot-starter-validation</artifactId>-->
<!--    </dependency>-->

    <!--spring-boot-web依赖:这个里面有定义全局异常需要的依赖+spring-boot-validation依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
```

### 2.domain上面加注解

,上面有注解,或者百度

#### 3.公共组件里面加一个类

```Java


import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AssertUtil {

    public static final String PHONE_CHECK = "^((13[0-9])|(14[0,1,4-9])|(15[0-3,5-9])|(16[2,5,6,7])|(17[0-8])|(18[0-9])|(19[0-3,5-9]))\\d{8}$";

    //手机的正则表达式
    private static final Pattern CHINA_PATTERN_PHONE = Pattern.compile(PHONE_CHECK);


    /**--------------------------------------------------------
     手机号断言
     --------------------------------------------------------**/
    public static void isPhone(String phone, GlobalEnumCode globalEnumCode){
        isNotEmpty(phone, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        Matcher m = CHINA_PATTERN_PHONE.matcher(phone);
        if(!m.matches()){
            throw new GlobalCustomException(globalEnumCode);
        }
    }


    /**--------------------------------------------------------
     断言 不为空，如果为空，抛异常
     --------------------------------------------------------**/
    public static void isNotEmpty(String text,GlobalEnumCode globalEnumCode) {
        if (text == null || text.trim().length() == 0) {
            throw new GlobalCustomException(globalEnumCode);
        }
    }


    /**--------------------------------------------------------
     断言对象为空
     --------------------------------------------------------**/
    public static void isNull(Object obj ,GlobalEnumCode globalEnumCode){
        if(obj != null){//不等于空就盘异常
            throw new GlobalCustomException(globalEnumCode);
        }
    }
    public static void isNotNull(Object obj ,GlobalEnumCode globalEnumCode){
        if(obj == null){//为空就跑异常
            throw new GlobalCustomException(globalEnumCode);
        }
    }

    /**--------------------------------------------------------
     断言false,如果为true,我报错
     --------------------------------------------------------**/
    public static void isFalse(boolean isFalse ,GlobalEnumCode globalEnumCode){
        if(isFalse){
            throw new GlobalCustomException(globalEnumCode);
        }
    }
    public static void isTrue(boolean isTrue ,GlobalEnumCode globalEnumCode){
        if(!isTrue){//不等于True就抛异常
            throw new GlobalCustomException(globalEnumCode);
        }
    }


    /**--------------------------------------------------------
     断言两个字符串一致
     --------------------------------------------------------**/
    public static void isEquals(String s1, String s2 , GlobalEnumCode globalEnumCode){
        isNotEmpty(s1, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        isNotEmpty(s2, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        if(!s1.equals(s2)){
            throw new GlobalCustomException(globalEnumCode);
        }
    }
    public static void isEqualsTrim(String s1,String s2 ,GlobalEnumCode globalEnumCode){
        isNotEmpty(s1, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        isNotEmpty(s2, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        if(!s1.trim().equals(s2.trim())){
            throw new GlobalCustomException(globalEnumCode);
        }
    }

    public static void isEqualsIgnoreCase(String s1,String s2 ,GlobalEnumCode globalEnumCode){
        isNotEmpty(s1, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        isNotEmpty(s2, GlobalEnumCode.PARAN_IS_NULL_ERROR);
        if(!s1.trim().equalsIgnoreCase(s2.trim())){
            throw new GlobalCustomException(globalEnumCode);
        }
    }





    /**--------------------------------------------------------
     手机号断言
     --------------------------------------------------------**/
    public static void isPhone(String phone,String message){
        Matcher m = CHINA_PATTERN_PHONE.matcher(phone);
        if(!m.matches()){
            throw new RuntimeException(message);
        }
    }


    /**--------------------------------------------------------
     断言 不为空，如果为空，抛异常
     --------------------------------------------------------**/
    public static void isNotEmpty(String text, String message) {
        if (text == null || text.trim().length() == 0) {
            throw new RuntimeException(message);
        }
    }


    /**--------------------------------------------------------
     断言对象为空
     --------------------------------------------------------**/
    public static void isNull(Object obj , String message){
        if(obj != null){
            throw new RuntimeException(message);
        }
    }
    public static void isNotNull(Object obj , String message){
        if(obj == null){
            throw new RuntimeException(message);
        }
    }

    /**--------------------------------------------------------
     断言false,如果为true,我报错
     --------------------------------------------------------**/
    public static void isFalse(boolean isFalse , String message){
        if(isFalse){
            throw new RuntimeException(message);
        }
    }
    public static void isTrue(boolean isTrue , String message){
        if(!isTrue){
            throw new RuntimeException(message);
        }
    }


    /**--------------------------------------------------------
     断言两个字符串一致
     --------------------------------------------------------**/
    public static void isEquals(String s1,String s2 , String message){
        isNotEmpty(s1, "不可为空");
        isNotEmpty(s2, "不可为空");
        if(!s1.equals(s2)){
            throw new RuntimeException(message);
        }
    }
    public static void isEqualsTrim(String s1,String s2 , String message){
        isNotEmpty(s1, "不可为空");
        isNotEmpty(s2, "不可为空");
        if(!s1.trim().equals(s2.trim())){
            throw new RuntimeException(message);
        }
    }

    public static void isEqualsIgnoreCase(String s1,String s2 , String message){
        isNotEmpty(s1, "不可为空");
        isNotEmpty(s2, "不可为空");
        if(!s1.trim().equalsIgnoreCase(s2.trim())){
            throw new RuntimeException(message);
        }
    }

}
```

### 4.controller.

在接口需要校验参数的对象前面加上此注解代表开启参数校验：@Valid:具体百度

@Valid 或者 @Validated都可以标识需要进行校验，在类上也可以加该注解

```Java
    @RequestMapping(value = "/{id}",method = RequestMethod.GET)
    public JSONResult get( @Valid  @PathVariable("id")Long id){}

```

### 5.测试

```Java
        String i1= "1";
        String j2= "2";
        AssertUtil.isEquals(i1,j2,GlobalEnumCode.COURSE_EXISTED_ERROR);
```

## springcloud继承Redis

### 1 . 导入依赖

```xml

        <!--整合Redis , 底层可以用jedis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <!--排除redis默认的java开发客户端依赖，
            因为高并发情况下会有内存溢出问题，我们使用jedis来操作Java-->
            <exclusions><!--移除指定依赖-->
                <exclusion>
                    <groupId>io.lettuce</groupId>
                    <artifactId>lettuce-core</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--引入redis的java客户端包，jedis依赖-->
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>
        <!--        redis依赖-->
```

### 2 . 序列化的类: 

Redis序列化配置

配置了这个的时候 

就不要要存入的对象去实现序列化接口   (implements Serializable )

```Java

import com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import javax.annotation.Resource;

//缓存的配置
@Configuration
public class RedisConfig {

    @Resource
    private RedisConnectionFactory factory;

    //使用JSON进行序列化
    @Bean
    public RedisTemplate<Object, Object> redisTemplate() {
        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();

        redisTemplate.setConnectionFactory(factory);
        //JSON格式序列化
        GenericFastJsonRedisSerializer serializer = new GenericFastJsonRedisSerializer();
         //key的序列化
        //redisTemplate.setKeySerializer(serializer);
        //value的序列化
        redisTemplate.setValueSerializer(serializer);
        //hash结构key的序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //hash结构value的序列化
        redisTemplate.setHashValueSerializer(serializer);
        return redisTemplate;
    }

} 
```

### 3.yml配置Redis

```yml
spring:
  redis:                    #Redis相关
    database: 0
    host: 127.0.0.1         #地址
    port: 6379              #端口号
    password: 123456        #Redis密码
    jedis:
      pool:
        max-wait: 2000ms
        min-idle: 2
        max-idle: 8
```

4.注入使用 

```Java
    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;
```

## Seata分布式事务

### 主业务方集成Seata

#### 1.安装:

seata

seata安装 : 

seata-server-1.1.0解压即安装

```
1.集成seata
	导包
	yml的配置
2.让rm来做数据库的操作	
	添加一个configuration
3.需要写配置文件
	cv就好(稍微知道这个文件里面到底做了啥)
4.改注解
	之前的enabletransactionManagement(单个服务的事务)去掉
	如果有@transaction的注解  去掉
	Springboot的启动类上面 (exclude DataSource的自动配置)	
5.undo
	存db---->建表
6.业务上面加@globaltransaction......   只需要在主服务上加  其它调用的不加
```

#### 2.主业务方相关配置

主业务方(调用方)方user里面集成seata导入依赖, 

```xml
<!--seata依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
</dependency>
<!--seata依赖-->
<!--连接池依赖    注意看之前是否已经有了此依赖-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.9</version>
</dependency>
<!--连接池依赖    注意看之前是否已经有了此依赖-->
```

#### 3.;yml配置,

```yaml
seata:   #顶格
  enableAutoDataSourceProxy: false #关闭DataSource代理的自动配置，我们要手动配置  seata顶格
spring:     #顶格
  cloud:
    alibaba:
      seata:
        tx-service-group: fsp_tx_group #这里和file.conf中事务组名一样(vgroupMapping.)这个点后面的
```

#### 4.拷贝配置

#### resources/file.conf

```java
transport {        # 通信这个就是TC通道
  # tcp udt unix-domain-socket
  type = "TCP"
  #NIO NATIVE
  server = "NIO"
  #enable heartbeat
  heartbeat = true            # 心跳
  # the client batch send request enable
  enableClientBatchSendRequest = true    # 允许客户端批量发送请求
  #thread factory for netty
  threadFactory {                       # 线程相关
    bossThreadPrefix = "NettyBoss"
    workerThreadPrefix = "NettyServerNIOWorker"
    serverExecutorThread-prefix = "NettyServerBizHandler"
    shareBossWorker = false
    clientSelectorThreadPrefix = "NettyClientSelector"
    clientSelectorThreadSize = 1
    clientWorkerThreadPrefix = "NettyClientWorkerThread"
    # netty boss thread size,will not be used for UDT
    bossThreadSize = 1
    #auto default pin or 8
    workerThreadSize = "default"
  }
  shutdown {       
    # when destroy server, wait seconds
    wait = 3               # 服务销毁的时候跑3秒钟
  }
  serialization = "seata"     # 序列化的方式
  compressor = "none"         # 是否压缩
}
service {
  #transaction service group mapping
  vgroupMapping.fsp_tx_group = "default"    
  # fsp_tx_group  一定要和配置文件  tx-service-group: fsp_tx_group  冒号后面的一样 default: 集群的名字
  #only support when registry.type=file, please don't set multiple addresses
  default.grouplist = "127.0.0.1:8091"
  #degrade, current not support
  enableDegrade = false        # 降级
  #disable seata
  disableGlobalTransaction = false     #不允许全局事务 双重否定表肯定
}

client {
  rm {
    asyncCommitBufferLimit = 10000
    lock {
      retryInterval = 10      #重试间隔时间
      retryTimes = 30			# 重试的时间
      retryPolicyBranchRollbackOnConflict = true
    }
    reportRetryCount = 5
    tableMetaCheckEnable = false
    reportSuccessEnable = false
  }
  tm {
    commitRetryCount = 5     #提交重试次数
    rollbackRetryCount = 5	# 回滚次数
  }
  undo {
    dataValidation = true           # 数据验证
    logSerialization = "jackson"    # 日志的序列化
    logTable = "undo_log"		   # 表
  }
  log {
    exceptionRate = 100             
  }
}
```

#### resources/registry.conf,

```java
registry {
  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
  type = "file"

  nacos {
    serverAddr = "localhost"
    namespace = ""
    cluster = "default"
  }
  eureka {
    serviceUrl = "http://localhost:8761/eureka"
    application = "default"
    weight = "1"
  }
  redis {
    serverAddr = "localhost:6379"
    db = "0"
    password = ""
    cluster = "default"
    timeout = "0"
  }
  zk {
    cluster = "default"
    serverAddr = "127.0.0.1:2181"
    session.timeout = 6000
    connect.timeout = 2000
    username = ""
    password = ""
  }
  consul {
    cluster = "default"
    serverAddr = "127.0.0.1:8500"
  }
  etcd3 {
    cluster = "default"
    serverAddr = "http://localhost:2379"
  }
  sofa {
    serverAddr = "127.0.0.1:9603"
    application = "default"
    region = "DEFAULT_ZONE"
    datacenter = "DefaultDataCenter"
    cluster = "default"
    group = "SEATA_GROUP"
    addressWaitTime = "3000"
  }
  file {
    name = "file.conf"
  }
}

config {
  # file、nacos 、apollo、zk、consul、etcd3、springCloudConfig
  type = "file"

  nacos {
    serverAddr = "localhost"
    namespace = ""
    group = "SEATA_GROUP"
  }
  consul {
    serverAddr = "127.0.0.1:8500"
  }
  apollo {
    app.id = "seata-server"
    apollo.meta = "http://192.168.1.204:8801"
    namespace = "application"
  }
  zk {
    serverAddr = "127.0.0.1:2181"
    session.timeout = 6000
    connect.timeout = 2000
    username = ""
    password = ""
  }
  etcd3 {
    serverAddr = "http://localhost:2379"
  }
  file {
    name = "file.conf"
  }
}

```

#### 5.排除DataSource自动配置

在启动类上的注解加属性

**@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class})**

#### 6.配置文件

#### MybatisPlus版本

```Java
import com.alibaba.druid.pool.DruidDataSource;
import com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean;
import io.seata.rm.datasource.DataSourceProxy;
import org.mybatis.spring.transaction.SpringManagedTransactionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

/**
 * 数据源代理(让你的seata来管理你的数据库)  
 */
@Configuration
//*EnableTransactionManagement*注释掉之前
public class DataSourceConfiguration {

    //mapper.xml路径
    @Value("${mybatis-plus.mapper-locations}")
    private String mapperLocations;

    //手动配置bean
    //通过配置文件里面的四大金刚
	//可以拿到connection
	//有了connection就可以有datasource
    @Bean
    @ConfigurationProperties("spring.datasource")
    public DataSource druidDataSource(){
        return new DruidDataSource();
    }
    /**
    * sessionFactoryBuilder-->dataSource--->sessionFactory
    * sessionFactory.openSession-->sqlSession
    * sqlSession操作我们的crud
    * @param dataSourceProxy
    * @return
    * @throws Exception
    */
    @Bean
    public MybatisSqlSessionFactoryBean sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception {
        //处理MybatisPlus
        MybatisSqlSessionFactoryBean factory = new MybatisSqlSessionFactoryBean();
        factory.setDataSource(dataSourceProxy);
        factory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
        //事务管理工厂
        factory.setTransactionFactory(new SpringManagedTransactionFactory());
        return factory;
    }
	
    //手动配置的dataSource的代理--需要我们yml中关闭自动代理
    @Primary
    @Bean("dataSource")
    public DataSourceProxy dataSourceProxy(DataSource druidDataSource) {
        return new DataSourceProxy(druidDataSource);
    }

}
```

#### Mybatis版本

```Java
package cn.itsource.hrm.config;

import com.alibaba.druid.pool.DruidDataSource;
import io.seata.rm.datasource.DataSourceProxy;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.transaction.SpringManagedTransactionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

//使用seata对DataSource进行代理---(让你的seata来管理你的数据库)  
@Configuration
public class DataSourceProxyConfig {

    //mapper.xml路径
    @Value("${mybatis.mapper-locations}")
    private String mapperLocations;

    //手动配置bean
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource druidDataSource(){
        return new DruidDataSource();
    }

    @Bean
    public SqlSessionFactory sessionFactory(DataSourceProxy dataSourceProxy) throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSourceProxy);
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
        //事务管理工厂
        sessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());
        return sessionFactoryBean.getObject();
    }

    @Bean
    public DataSourceProxy dataSource() {
        return new DataSourceProxy(druidDataSource());
    }
}
```



#### serviceImpl   方法上面加上

**@GlobalTransactional   //加了这个注解就不要加之前的局部事务注解了**

	之前的enabletransactionManagement(单个服务的事务)去掉
	如果有@transaction的注解  去掉
#### undolog表 --对应的服务里面加

数据库中创建表，涉及到事务的表都需要添加undolog

```java
-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

### 参与方集成

#### 被调用方的serviceImpl方法上不用加注解

#### 其它步骤和面完全一样

启动类上一样的要加

**@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class})**

## openfeign使用

注意 : 通过feign传对象 需要在传入方把对象转为JSON格式--转出方在转回来

### 1.导入依赖:

**feign接口需要使用到事务**

两边都需要导入依赖

```xml
   <!--引入OpenFeign依赖-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
```

两边的启动类上面都需要加注解  **@EnableFeignClients//开启openfeign客服端**

### 2.写feign暴露接口 

这里以produce去调store接口为例 

### product : controller层

```Java
/**
 * (Product)表控制层
 *
 * @author makejava
 * @since 2022-08-20 09:56:45
 */
@SuppressWarnings("all")
@RestController
@RequestMapping("/product")
@Transactional(readOnly = true,propagation = Propagation.SUPPORTS )
@Api(value = "接口类",description = "接口类的crud")//写在controller层对应的类上面
public class ProductController {
    /**
     * 注入userfeign的接口
     */
    @Autowired
    private StoreFeignClien storeFeignClien;
    @Autowired
    private ProductService productService;

    /**添加一个对象
     * @param productDto
     * @return
     */
    @Transactional
    @PostMapping("/insert")
    @ApiOperation("添加和修改操作")//SwaggerConfig注解
    public JsonResult Add(@RequestBody ProductDto productDto) {

        try {
            /**
             * product这边的添加
             */
            Product product = new Product();
            product.setPrice(productDto.getPrice());
            product.setName(productDto.getName());
            productService.insert(product);

            /**
             * 创建一个store对象,并且赋值
             */
            Store store = new Store();
            store.setProduct_id(product.getId());
            store.setNumber(productDto.getNumber());

            //调方法,添加store
            JsonResult jsonResult = storeFeignClien.insert(store);
            System.out.println("ProductController====="+JsonResult.me());

            return jsonResult;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return JsonResult.me().setMsg("操作失败");
    }
}
```

### product这边的storefeign接口

```Java
/**
 * 指定此接口是feign客服端接口,括号中的值就是你要调用的服务的引用名称
 */


import cn.xia.domain.Store;
import cn.xia.util.JsonResult;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

/**
 * 1.@FeignClient("store-server")：此注解会在服务启动时被你在启动类中加的@EnableFeignClients扫描，
 * 				他会去找他自己同级以及一下所有加了@FeignClient("user-server")的接口，找到之后会使用动态代理
 * 				创建接口的实现类，实现类中他会根据接口的请求路径+方法的请求方式、参数、返回值、请求路径，合在一起
 * 				使用RestTemplate+Ribbon帮我们进行调用
 *   store-server   去网管里面cv最保险
 */

@FeignClient(name = "store-server",fallbackFactory = StoreFallbackFactory.class)
@RequestMapping("/store")
public interface StoreFeignClien {


    /**
     * 添加一个对象:相当于是代理的store的接口,从这里进入到store
     *  请求的方式,请求地址毛和调用方一模一样
     *  方法的返回值也和被调方一模一样
     *  请求参数也和被调方一模一样
     *  建议直接cv---直接把store层的接口整个cv过来删除方法体和修饰
     *   添加和修改只能用post请求方式
     * @param store
     * @return
     */
    @PostMapping("/store/insert")
     JsonResult insert(@RequestBody Store store);
}
```

### product这边的熔断类

使用springcloud第一代的 有eureka使用熔断机制(被调用方需要导入依赖)

被调用方 依赖如下 : 

```xml
        <!--使用hystrix首先要添加依赖0.1-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
```

双方

```yml
feign:      #顶格
  hystrix:
    enabled: true #开启Hystrix开启熔断支持
```

### 熔断的类

```Java
@Component//很容易忘记
public class StoreFallbackFactory implements FallbackFactory<StoreFeignClien> {
    /**
     * 专门为我们创建降级类
     * @param throwable
     * @return
     */
    @Override
    public StoreFeignClien create(Throwable throwable) {
        return new StoreFeignClien() {

            /**
             * 添加的熔断方法
             * @param store
             * @return
             */
            @Override
            public JsonResult insert(Store store) {
                System.out.println("StoreFallbackFactory=====执行兜底方法=====");
                return JsonResult.me().setMsg("熔断了.抱歉jar了");
            }
        };
    }
}
```

### store这边的controller层

```Java

/**
 * (Store)表控制层
 *
 * @author makejava
 * @since 2022-08-20 09:56:45
 */
@RestController
@RequestMapping("/store")
@Transactional(readOnly = true,propagation = Propagation.SUPPORTS )
public class StoreController {
    /**
     * 注入对象
     */
    @Autowired
    private StoreService storeService;

    @PostMapping("/store/insert")
    @Transactional
    public JsonResult insert(@RequestBody Store store){
        try {
                storeService.insert(store);
            return JsonResult.me().setMsg("两者都添加成功");
        } catch (Exception e) {//如果操作失败就执行catch
            e.printStackTrace();
            return JsonResult.me().setMsg("操作失败");
        }
    }
}
```



## 阿里云存储使用

## 视频上传

## MQ相关

## 支付宝使用

## 邮件发送

### 第一步,导入依赖

```xml
        <!--对邮件的支持jar-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
```

### 第二步.配置邮箱

```yml
配置邮箱
spring:    
  mail:                 #mail顶格      
    host: smtp.qq.com   # 设置邮箱主机(服务商),这里使用QQ邮件服务器
    username: 1173876523@qq.com  # 设置用户名 - 发送方
    password: nszttekztmmngcjj   # 设置密码，该处的密码是QQ邮箱开启SMTP的授权码而非QQ密码
    properties:
      mail:
        smtp:
          auth: true  # 必须进行授权认证，它的目的就是阻止他人任意乱发邮件
          starttls: #SMTP加密方式:连接到一个TLS保护连接
            enable: true
            required: true
```

### 发送简单邮件

```java
@SpringBootTest(classes = ApplicationStart.class)
@RunWith(SpringJUnit4ClassRunner.class)
public class EmailTest {
    
   @Autowired
   private JavaMailSender javaMailSender;

   @Test
    public void send1(){
        SimpleMailMessage mailMessage = new SimpleMailMessage();
        //设置发送人
        mailMessage.setFrom("1104829999@qq.com");
        //邮件主题
        mailMessage.setSubject("新型冠状病毒防护指南");
        //邮件内容：普通文件无法解析html标签
        mailMessage.setText("<h1>好好在家待着.....</h1>");
        //收件人
        mailMessage.setTo("659769499@qq.com");
        //发送邮件
        javaMailSender.send(mailMessage);
    }
}
```

### 发送复杂邮件

```java
    @Autowired
    private JavaMailSender javaMailSender;

@Test
public void send2() throws MessagingException {
    //创建复杂邮件对象
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    //发送复杂邮件的工具类
    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true,"utf-8");
    helper.setFrom("1104829999@qq.com");
    helper.setSubject("店铺激活邮件");
    helper.setText("<h1>你的店铺已经注册!!!</h1><img src='http://dfs.java.itsource.cn/group1/M00/00/B9/rBE3kWD_fEuALou2AAB4rV4bI7c231.jpg' ><a href='http://localhost:8080/shop/active/22'>点击该链接激活</a>",true);
    //添加附件
    helper.addAttachment("p7.jpg",new File("C:\\Users\\Administrator\\Pictures\\photos\\p7.jpg"));
    helper.addAttachment("g1.gif", new File("C:\\Users\\Administrator\\Pictures\\g1.gif"));
    //收件人
    helper.setTo("659769499@qq.com");
    javaMailSender.send(mimeMessage);
}
```



## wmware虚拟机安装

老杨10-19 视频里面-网盘里面写下载下来,进行安装.

安装注意:

1.自定义,124勾选

启动是检车更新,不勾选

帮助改善,不勾选

安装完成.





### 虚拟一台主机centos主机

1,创建虚拟机

2.自定义, 10-64-16-10-8

3.安装程序操作系统,点击稍后安装-下一步

4,客服端操作系统linux--版本centos 64位-下一步

5.位置是值得你安装到哪里-首次安装位置D:\Documents\Virtual Machines\CentOS7

6,处理器2.每个处理器核心数量2

7.内存,整个两个G

8,使用网络地址装换(也就是选第二个)

9.推荐LSI logic(L)

10 . SCSI 推荐

11 .创建新的虚拟机磁盘

12 . 20G     将虚拟机存储为单个文件

13 . 下一步

14 . 声卡和打印机可以移除  其它可以留着

15 .完成

安装完成  .



等到安装系统

安装系统:

​	1 点击编辑虚拟机设置

​	2.CD/DVD .使用ISO镜像文件

​		CentOS-7-x86_64-DVD-1810

​	3.点击开启虚拟机,他就自己帮你装了

两个确定 ---选择中文 

软件选择:桌面-点击完成

偶尔选着安装位置出问题-点进去,完成,就好了,

网络点进去打开一下

开始安装==========

电脑密码: 账户root密码 asd123

创建用户,asd123-密码 asd123

然后等待

许可授权,点击同意-完成

右下角完成配置

# Lambda表达式

查阅网站 : https://www.runoob.com/java/java8-lambda-expressions.html

```
Lambda 表达式的简单例子:

// 1. 不需要参数,返回值为 5  
() -> 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -> 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -> x – y  
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -> x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -> System.out.print(s)
```



# 